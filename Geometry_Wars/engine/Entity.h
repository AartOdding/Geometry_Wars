#pragma once

#include <bitset>
#include <array>
#include <algorithm>
#include <iostream>
#include <vector>
#include <cassert>
#include <typeinfo>
//#include "engine/Component.h"



class Component;
//Deze moeten allemaal een keer naar een constants class
constexpr auto maxComponents = 10;

//Array[Components] for indexation
//Vector<Components> for update
//Dubbele component managements, maar moet wel want anders is het allemaal kut
//Sterker nog 3 dubbelle check want ook bitset

using EntityID = std::size_t;
using ComponentBitSet = std::bitset<maxComponents>;
using ComponentArray = std::array <Component *, maxComponents >;

/*! \file Entity.h
	\brief The Entity in the entity component system. The Entity contains components and manages them after creation
*/

/*! \def EntityID
	\brief type alias that ensures Entity ID's are always a type of std::size_t
*/

/*! \def ComponentBitSet
	\brief type alias to keep a list of maxComponents bits. This is used to see if an entity contains a component
*/

/*! \def ComponentID
	\brief type alias for an array that can contain all the possible componentTypes that exists
*/

/*! \def maxComponents
	\brief type constant to limit the amount of components that can be used by the game per entity
*/

/*! \fn Entity(EntityID id)
	\brief Constructor of Entity
	
	\param id unique id generated by the EntityManager
*/

/*! \fn ~EntityManager()
	\brief Destructor of Entity
*/

/*! \fn update()
	\brief Go over all components and call the execute function
*/

/*! \fn setComponents(T, ...Args)
	\brief Template function that asserts a given type the function should run has Component as a base class. Creates a new component of given type with passes through parameters and adds it to the corresponding Entity variables
*/

/*! \fn setComponentFlag(Component *)
	\brief sets the Componentflag of given component

	\param Component that should be flagged.
*/

/*! \fn setChangedComponent()
	\brief sets flag that one or more components are changed
*/

/*! \fn removeComponent<T>()
	\brief template function that marks a component of Type T to be removed in the next clean up. Components cannot be removed directly because they may still be relevant in the current update loop
*/

/*! \fn isActive()
	\brief request if entity is still active

	\param bool alive
*/

/*! \fn hasComponent<T>()
	\brief returns if the current entity contains a component of Type T

	\param bool 	
*/

/*! \fn getComponent<T>()
	\brief returns the component of Type T the entity contains

	\param T *
*/

/*! \var EntityID id
	\brief contains a unique number to identify the entity
*/


/*! \var ComponentBitSet containsComponents
	\brief a bitset list to keep track of components an entity contains
*/
/*! \var ComponentArray componentArray
	\brief List of components that can be indexed by ComponentID. Finding components is much faster by lookup than using the componentlist vector
*/
/*! \var bool changedComponentFlag
	\brief a flag to see if the entity should clean its componets
*/

/*! \var std::vector<std::unique_ptr<Component>> componentList
	\brief vector of all the current components the entity has. This list is used for easy updating of the components.
*/
/*! \var bool alive
	\brief flag for the entity manager to look if this entity should be deleted.
*/

class Entity
{
private:
	EntityID id;
	ComponentBitSet containsComponents;
	ComponentArray componentArray;
	bool changedComponentFlag;
	std::vector<std::unique_ptr<Component>> componentList;
	bool alive = true;
	bool removeAll = false;
public:
	Entity() = delete;
	Entity(EntityID i);

	void update();
	void draw();
	virtual ~Entity();

	void setComponentFlag(Component *);

	template<typename T, typename... Args>
	void setComponent(Args&&... values) {
		static_assert(std::is_base_of<Component, T>::value);
		T * component = new T(std::forward<Args>(values)...);
		component->entity = this;
		auto componentID = EntityManager::template getLastComponentID<T>();
		component->id = componentID;
		componentArray[componentID] = component;
		containsComponents[componentID] = true;
		std::unique_ptr<Component> uniqueComponent(component);
		componentList.emplace_back(std::move(uniqueComponent));
		//std::cout << "De id in de manager: " << EntityManager::template getLastComponentID<T>() << std::endl;
		//component->print();
	}

	//TODO: DENNIS DOE FIX
	template<typename T>
	T * getComponent() {
		static_assert(std::is_base_of<Component, T>::value);
		auto componentID = EntityManager::template getLastComponentID<T>();
		T * component = static_cast<T*>(componentArray[componentID]);
		return component;
	}

	template<typename T>
	bool hasComponent() {
		static_assert(std::is_base_of<Component, T>::value);
		auto componentID = EntityManager::template getLastComponentID<T>();
		return containsComponents[componentID];
	}


	//willen we components recyclen of willen we gewoon vernietigen
	//Bij recyclen moeten we iets maken die kijkt of de components al gebruikt worden door iets, aka componentmanager :'(
	template<typename T>
	void removeComponent() {
		static_assert(std::is_base_of<Component, T>::value);
		auto componentID = EntityManager::template getLastComponentID<T>();
		if (containsComponents[componentID]) {
			//containsComponents[componentID] = false;
			auto component = componentArray[componentID];
			component->remove = true;
			component->id = componentID;
			this->changedComponentFlag = true;
			//std::cout << "Hello I have been removed!" << std::endl;
			//ComponentArray[componentID] = nullptr
			//auto index = std::find(componentList.begin(), componentList.end(), component);
			//componentList.at(index-componentList.begin()).swap(componentList.at(componentList.end()- componentList.begin()));
			//std::iter_swap(index, componentList.end()-1);
			//componentList.pop_back();
			//std::cout << "De component: " << component->toString() << " will be removed" << std::endl;
		}
	}
	
	/*
	*@Aart: Weet jij hoe je de type van een parent van een unique pointer kunt opvragen?
	* Anders blijf ik mijn kut oplossing gebruiken
	*/
	template<typename T>
	bool removeFlaggedComponent() {
		static_assert(std::is_base_of<Component, T>::value);
		auto componentID = EntityManager::template getLastComponentID<T>();
		containsComponents[componentID] = false;
	}

	void removeAllComponents();

	void setChangedComponent();
	bool changedComponents();
	void cleanUp();
	bool isActive();

	//virtual const int GetStaticEntityID() const = 0;

	//inline const int GetEntityID() const { return this->id; }

	//inline const int GetEntityID() const { return this->id; }

};

